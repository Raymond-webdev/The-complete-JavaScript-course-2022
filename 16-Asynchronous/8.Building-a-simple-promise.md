## Building a simple promise

- So let's get to work and we create a new promise using the promise constructor. So that's new promise like this. So just like many other built-in objects. And so what this means is that promises are essentially just a special kind of object in JavaScript. Now the promise constructor takes exactly one argument and that is the so-called executor function. So we need to pass in a function here. And so again, this one is called executor. Now, as soon as the promise constructor runs, it will automatically execute this executor function that we pass in. And as it executes this function here, it will do so by passing in two other arguments. And those arguments are the resolve and reject functions. So reject like this. So we will use them here in a second, but for now let's actually build this executor function. And also we should probably store the result. So this new promise in some variable, so lottery promise. 
- All of this here we'll create a new promise that we're gonna store into this variable. So it's just like, for example, the fetch function, which also creates a new promise. Now this executor function that we specified here is the function which will contain the asynchronous behavior that we're trying to handle with the promise. So this executor function should eventually produce a result value. So the value that's basically gonna be the future value of the promise. And so let's do exactly that right here in the executor function and starting with a simplified version. Now, in our lottery example, let's say that we actually win in 50% of the cases and to lose in the other 50%. So a very simplified example, just to make this a bit more fun. And so what I'm gonna do is to simply generate a random number which remember is gonna be between zero and one. And so I can simply say, if this number here is greater or equal than 0.5, then I want to call the resolve function. And so now this is where this resolve function that was passed into the executor function comes into play. In this situation here, we say that we win the lottery. And so therefore that means a fulfilled promise. And in order to set the promise as fulfilled, we use the resolve function. So basically calling the resolve function like this, will Mark this promise as a fulfilled promise, which we can also say a resolved promise. And that's the reason why this method here is called resolve. Now into the resolved function here we pass the fulfilled value of the promise so that it can later be consumed with the den method. So of course we are going to handle the results of this promise just like we handled any other promise with the den method. 
```
- Building a Simple Promise
const lotteryPromise = new Promise(function (resolve, reject) {
  console.log('Lotter draw is happening ðŸ”®');
  setTimeout(function () {
    if (Math.random() >= 0.5) {
      resolve('You WIN ðŸ’°');
    } else {
      reject(new Error('You lost your money ðŸ’©'));
    }
  }, 2000);
});

lotteryPromise.then(res => console.log(res)).catch(err => console.error(err));
```
- So again, whatever value we pass into the resolve function here is gonna be the result of the promise that will be available in the den handler. And so in this case, let's simply pass in a string here and let's use some emoji again to make it a bit more fun. And so now let's handle the opposite case. So where we basically want to Mark this promise as rejected. And so, as you can imagine for that we can call the reject function. Then into the reject function, we pass in the error message that we later want to be able in the catch handler, so in the catch method. So here, let's just say you lost your money and then just some poop emoji. So give this a safe here. So just to quickly recap, before we consume this promise here, we created an executor function which is gonna be called by this promise constructor as soon as it runs, so basically immediately. Then the promise calls this function and passes in the resolve and the reject functions so that we can then use them to mark the promise as either resolved so as fulfilled or as to rejected. And so you see that this promise is eventually going to move to either the fulfilled state or the rejected state. So we always need to make sure that the promise ends up in one of these two states. And so now it's time to actually try this out by consuming this promise that we just built. So lottery promise is going to be a promise object at this point. And so then as always, we can call the den method, and then just like before the den method needs a callback function that is going to be called with the resolved value of the promise. So that's call this res here and then let's simply log it to the console. And of course, once again, this could be any name here. And now let's also catch any errors, then so here also as always, we will simply log it to the console as an error. Now, so that's actually it already. So what do you think this res value here is going to be, or this error is going to be. Well, as I just explained before the resolved value of the promise is going to be this one that we pass in here. And so therefore the value that we're gonna log in the case that the promise is successful is going to be exactly this string that we passed into the result function and the same is to with the error. So the error here is going to be simply this one because that's the string that we passed into the reject function. So let's see and indeed we get or error, so you lost your money. And so as we keep reloading, we should then see these different states according to this random number that was generated here.
