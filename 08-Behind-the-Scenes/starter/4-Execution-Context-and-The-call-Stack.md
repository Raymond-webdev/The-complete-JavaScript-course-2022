## Execution Contexts and The Call Stack

- In this lecture, let's answer the question how is JavaScript code executed? We already know that it happens in a call stack in the engine, but let's dig a bit deeper now. And let's start by supposing that our code was just finished compiling, just in a way that we learnt in the last lecture, so the code is now ready to be executed. What happens then is that a so-called **global execution context** is created for the **top level code** and top level code is basically code that is not inside any function. 
 - So we know that a global execution context is created for top level code. 
 - But What exactly is an execution context? Well, an execution context is an abstract concept, an environment in which a piece of JavaScript is executed. It's like a box that stores all the necessary information for some code to be executed, such as local variables or arguments, passed into a function so JavaScript code always run inside an execution context. 
 - Now in any JavaScript project, no matter how large it is, there's only ever one global execution context. It's always there as the default context, and it's where top level code will execute.
 - Now that we have an environment where the top level code can be executed, it finally is executed and there is not a lot to say about the execution itself is just the computer CPU processing the machine code that it received. 
 - And once this first top level code is finished, functions finally start to execute as well.
 -And here is how that works, for each and every function call, a new execution context will be created containing all the information that is necessary to run exactly that function andt the same goes for methods because they are simply functions attached to objects and all these execution contexts together make up the call stack.
 - Now when all functions are done executing, the engine will basically keep waiting for callback functions to arrive so that it can execute these, for example, a callback function associated with a click event.
 - The first thing that's inside any execution context is a so-called variable environment. In this environment, all variables and function declarations are stored, and there is also a special arguments object. This object contains, as the name says, all the arguments that were passed into the function that the current execution context belongs to because each function gets its own execution context as soon as the function is called. So basically all the variables that are somehow declared inside function will end up in its variable environment. 
 - However, a function can also access variables outside of the function and we have already seen that in action throughout this course, specially in the projects of the previous section. And this works because of something called these **scope chain** and the scope chain basically consists of references to variables that are located outside of the current function.
 - Finally, each context also gets a special variable called **.this** keyword. 
 - So variable environment scope change and **.this** keyboard is generated in a so-called **creation phase**, which happens right before execution. And now just one final but very important detail that we need to keep in mind is that execution contexts belonging to arrow functions do not get their own arguments keyboard, nor do they get the **this** keyword.
- **The call stack** together with **the memory heap** makes up the JavaScript engine itself. 
- **The call stack** is basically a place where execution contacts get stacked on top of each other in order to keep track of where we are in the programmes execution. So the execution context that is on top of the stack is the one that is currently running, and when it's finished running, it will be removed from the stack and execution will go back to the previous execution context.

